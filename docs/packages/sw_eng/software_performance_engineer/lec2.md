# Lec 2 Bentley 程序优化的法则

算法设计可以显著减少解决问题所需的工作量，例如用 Θ(n log n) 时间复杂度的排序替代 Θ(n²) 时间复杂度的排序。 然而，减少程序的工作量并不一定会自动减少其运行时间，这是由于计算机硬件的复杂特性：

- 指令级并行（ILP）
- 缓存
- 向量化，
- 推测执行和分支预测，

 尽管如此，减少工作量仍然是减少整体运行时间的一个有效启发式方法。

我们这门课的的优化是，是与体系结构相关的优化

## 总览

![image-20240928152111113](http://198.46.215.27:49153/i/66f7ae6be15b3.png)

- 数据结构层面
- 循环语句
- 逻辑语句
- 函数层面

## 数据结构

### 打包和编码

Packing and encoding。打包的想法是是将多个数据值存储在一个机器字中，而编码的想法是数据值转换为需要更少位数的表示方式。

示例：编码时间。 字符串形式的日期“2018年9月11日”会占用 18 个字节，超过两个 64 位（double word）的机器字大小。每当我们操作日期时，必须移动这些字节，增加了开销。假设我们只需要存储从公元前 4096 年到公元 4096 年之间的日期。这大约有 365.25 × 8192 ≈ 300 万个日期。使用二进制表示时，编码这些日期大约需要 ⎡log₂(3 × 10⁶)⎤ ≈ 22 位，因此可以轻松地存储在一个 32 位的机器字中

### 数据结构增强

Augmentation，通过向数据结构中添加额外信息，使常见操作所需的工作量减少，从而提高操作效率。

示例：单链表拼接。假设我们有两个单链表，要将一个链表（A）拼接到另一个链表（B）的末尾。由于单链表只有指向下一个节点的指针，没有直接指向尾部的指针，因此我们需要遍历链表 A 的所有节点，直到找到它的末尾（空指针位置），然后将这个空指针指向链表 B 的开头。这个过程的时间复杂度是 O(n)，其中 n 是链表 A 的长度。

**增强链表**：如果我们在链表结构中增加一个尾指针（tail pointer），直接指向链表的最后一个节点，那么拼接操作就可以直接找到链表 A 的末尾，无需遍历整个链表。这样拼接操作可以在常数时间（O(1)）内完成，大大提高效率

### 预计算

Precomputation， 预计算的思想是提前进行计算，以避免在“任务关键”的时刻进行计算。

为了优化这一过程，**预计算**的思想是：在程序初始化时提前计算出一张二项式系数表（比如一个二维数组），在运行时通过查表直接获取结果，而不再进行实时计算。

### 编译期间初始化

编译时初始化的思想是在编译期间存储常量的值，从而在程序执行时节省工作量。

示例： 元编程（metaprogramming）。

![image-20240928160025364](http://198.46.215.27:49153/i/66f7b79c36edf.png)

### 缓存

**缓存**的思想是将最近访问过的结果存储起来，以便程序不必再次计算它们

### 利用稀疏性

**利用稀疏性**的思想是避免存储和计算零值。简而言之，就是“最快的计算方式是不进行计算

示例： CSR 压缩稀疏行矩阵表示法

## 逻辑

Constant Folding and Propagation