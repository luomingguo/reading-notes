# Lec 12 故障恢复（Part I)

我们将开始讨论ARIES和恢复。这是一篇冗长且难度较高的论文，我们将在两次讲座的大部分时间里探讨它。重点理解恢复协议的核心。

[ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging, 1992](https://web.stanford.edu/class/cs345d-01/rl/aries.pdf) ，读1-7节，泛读12和13节

## 加锁粒度

### 背景：权衡

性能和一致性的权衡

- 一个涉及许多记录的事务将不得不获取许多锁！
  - 这增加了每个操作的开销
- 一个只需要访问部分表格但却锁定整个表格的事务将限制并发性。
- 允许的情况包括：
  - 当事务只需要修改或查询少量记录时， 最好使用较细粒度的锁定机制，如记录级别或页面级别的锁定
  - 锁定多个记录的事务使用表格锁

### 多粒度锁定增加了复杂性

- 需要确保不同粒度的锁可以共存

- **并非简单问题，例如：**

  - 如果事务 T1 尝试在表 A 的某个记录上获取锁，而事务 T2 已经获取了表 A 的写锁，则应该阻止 T1 获取该记录的锁

- 解决方案： 引入层次锁（或者说，锁的层次结构）

  ```
  Table
  	Page
  		Record
  或者是
  Table
  	Range
  		Record
  ```

  关键思想： **在获取低级别锁（如记录锁）之前，先获取高级别锁（如表锁）**。

> 如果一个事务想要修改单个记录？它是否需要在整个表上获取 X 锁定？
>
> 这似乎违背了记录级别锁定的目的！

----

## 意向锁(Intention Locks)

解决方案： 意向锁

```
Table
	Page
		Record
```

关键思想：

- 假设事务 T1 想要写记录 R1
- 需要在包含 R1 的表和页上获取意向锁
- 意向锁在更高层次上标记某个事务在较低层次上有一个锁
- 意向锁
  - 可以是读意向（IS）锁或写意向（IX）锁
  - 防止当一个事务在较低层次对象上工作时，其他事务获取整个对象的锁。例如， 当 T1 在记录 R1 上有写锁时，意向锁确保其他事务不能在 T1 完成之前锁定整个表进行修改。
  - 不同事务可以同时持有对同一个对象的锁，前提是这些锁是兼容的。下面是 *锁兼容性矩阵*

> [!NOTE]
>
> 根据锁在**意图**分类，有：
>
> - **S (Shared)**：共享锁，提供读取权限。
> - **X (eXclusive)**：排他锁，提供读取和写入权限。
> - **IX (Intention eXclusive)**：意向排他锁。
> - **IS (Intention Shared)**：意向共享锁。
> - **SIX (Shared Intention eXclusive)**：共享意向排他锁。
>
> 锁在**粒度**上分类，包括（从上到下，层次越来越高）：
>
> - 元祖（记录级别锁）--> 慢
> - 页
> - 表
> - DB --> 限制并发

| T2 trying to acquire \ T1 holds | S    | X    | IX   | IS   | SIX  |
| ------------------------------- | ---- | ---- | ---- | ---- | ---- |
| **S**                           | ✔    |      |      | ✔    |      |
| **X**                           |      |      |      |      |      |
| **IX**                          |      |      | ✔    | ✔    |      |
| **IS**                          | ✔    |      | ✔    | ✔    |      |
| **SIX**                         |      |      |      |      |      |

从上图中我们可以发现

- 如果T1正在更新较低层次数据，T2不能读取整个层次的数据
- 如果T1正在读取较低层次数据，T2可以读取整个层次的数据
- 如果T1正在更新较低层次数据，T2不能更新整个层次的数据

- 如果T1正在读取较低层次数据，T2可以更新整个层次的数据

- 如果 T1 正在读取/更新较低层次的数据，T2 可以读取/更新较低层次的数据

  > 那如果它们尝试访问相同的较低层次对象呢？

  A: 较低层次的锁将会阻止它们



### 意图锁 （IS/IX ）的协议

1. 考虑事务 T 尝试在层次结构的第 j 层对记录 R 获取 S/X 锁
2. for each level L in 1 ... j - 1
   - 在L层中， R所在对象获取IS / IX 锁
     - 如果不能兼容，则阻塞
3. 获取记录的 S/X锁
4. 当释放锁的时候按照相反的顺序

![截屏2024-07-17 05.50.01](/Users/mac/Library/Application%2520Support/typora-user-images/%25E6%2588%25AA%25E5%25B1%258F2024-07-17%252005.50.01.png)

举个例子，如果想读取X记录， 先在X所在数据库加IS锁， 然后在X所在表获取IS锁， 接着在X所在页添加IS锁，最终将得到X的S锁。

> 思考题
>
> 给定上述的层次结构，准备将3个记录添加到同个表的两个页中
>
> ![截屏2024-07-17 05.52.24](http://198.46.215.27:49153/i/6696eb9dc58f8.png)
>
> 以下哪对事务可以在不阻塞的情况下并发执行？
>
> A) T1: Read P1 T2: Write A 
>
> B) T1: Write P2 T2: Read T 
>
> C) T1: Write P1 T2: Write P2 
>
> D) T1: Read P1 T2: Write C

C，D

## 恢复

恢复是关于你如何处理一个已经crashed的系统，主要有两件事：

- 确保故障时的原子性
- 确保故障时的持久性

当发生crash时， 所有的内存状态， 所有的进程，以及缓冲池中的所有内存都消失了，你只能从磁盘上面带回一些东西，通过恢复过程， 将数据库带入一个事务一致的状态，也就是说

- 要确保故障时的原子性
  - 需要撤销未被commit的工作
- 确保故障时的持久性
  - 已提交的事务保存在稳定存储（磁盘）上

> 为什么要回滚未提交的事务？ 为什么会出现未提交的事务？

- 系统崩溃后，所有的客户端连接都断掉了
- 一般不可能确定还有哪些工作没有完成
- 最好的选择是将数据库恢复到事务没有发生的状态
  - 保持原子性
  - 意味着客户端不能依赖未提交的结果

### DBMS运行时状态

![截屏2024-07-17 06.00.38](http://198.46.215.27:49153/i/6696ed8ed9719.png)

 在crash后

- 内存的东西，没了！

- 有些事务可能尚未把已经commit的状态回刷到表中——需要重做
- 有些事务可能把尚未commit的状态写入到表中了——需要撤销

关键思想： 日志记录了事务的开始和结束，以及对表进行写操作的内容。因此我们可以解决上述两个问题。

- 日志捕捉了所有写操作开始和结束的状态
  - 比如， 页 X 以前是 X0 现在是 X1
- 并且告诉我们哪些事务已经提交，哪些没有提交。

> 为什么我们需要记录写操作的内容？

- 如果没有，将无法判定写操作是否被应用
- 如果磁盘上没有表的状态，能够让我们重做已经提交的写操作
- 如果磁盘上有表状态， 能够让我们撤销未提交的写操作。

### 基于日志的恢复

#### 物理日志 vs. 逻辑日志

![截屏2024-07-17 06.41.23](http://198.46.215.27:49153/i/6696f71c32820.png)

逻辑日志：不直接关注数据在磁盘上的物理存储结构，而是记录操作的逻辑意义和效果。 比如: tid 100: sal += 1000

物理日志：关注数据在磁盘上的存储位置

虽然逻辑日志记录方式更为紧凑，但它要页必须准确地反映事务操作的变化状态，以便正确执行恢复过程中的撤销和重做操作。



#### 预写日志 WAL

预写日志 WAL (Write-Ahead logging) 策略是指所有的数据的修改操作之前，都会将修改操作写到日志记录中。日志记录包括

- 开始或提交事务
- 当系统执行写操作，将页数据写入到磁盘上的表时，这些写操作会被记录到日志中（读取操作不记录日志）

> 如果我们不这样，会有什么差错？或者说为什么要预写日志？

- 如果不这么做， 在未提交的事务中更新页面，系统崩溃（这时应该回滚该更新操作），但是，我们没有任何方法来知道页面是否已被更新。

- **在执行操作之前，先记录我们计划要做的事情，并在日志中留下足够的信息，以便我们可以确定是否已经执行了这些操作**。

  需要注意的是，我们必须将所有操作写两次，但日志记录是追加进行的，不像对数据库的写操作是随机的

#### 日志记录类型及其字段

- Start（SOT）
  - LSN: 递增的日志序列号
  - TID：事务ID
  - 记录事务的开始，标记事务的起始点
- End（EOT）
  - LSN
  - TID
  - 结果(commit 还是 abort)
  - 记录事务的结束
- UNDO
  - LSN
  - TID
  - Before image: 事务执行前快照
  - 记录撤销操作，用于事务回滚
- REDO
  - LSN
  - TID
  - after image：事务执行后的数据快照。
  - 记录重做操作，用于在系统崩溃后恢复事务提交的修改。
- CheckPoint（检查点
  - LSN
  - TID
  - state to limit how much is logged：记录检查点的状态，用于限制日志记录的量
- CLR（Compensation Log Record，补偿日志记录 )
  - LSN
  - TID
  - 允许重新启动恢复过程的记录



#### 日志的两个复杂性

##### 脏页写回

> 有时候我们想要将脏页(尚未commited)刷回数据库， 为什么？

- 如果我们不将脏页面写回，它们必须在内存中保存直到事务完成
  - 考虑一个更新表中所有记录的事务。如果数据库不将脏页面写回，这些页面就必须在事务执行期间一直保持在内存中，内存可能顶不住这么大。
- 将脏页写回数据库的过程称为，Steal
- 数据库执行“STEAL”时，即使事务尚未提交，也可以将脏页面写回数据库。当恢复时，需要用``UNDO``来移除未提交的事务

##### 已提交的更改未写回

> 如果每次提交都把页面刷回，不就可以解决这个问题吗？

- 这样做会让性能变慢，需要在commit时候进行大量的写操作

- 不强制在提交时写回所有写入的数据库被称为NO FORCE
- 追加日志记录足以确保可恢复性，因此对于可恢复性来说，FORCE是不必要的
- NO FORCE需要通过``REDO``将记录的写操作应用到数据库

这里我们会发现，Steal、Non-force 与 UNDO/REDO 是一一对应的。

- 如果我们采用了Steal策略，则我们需要UNDO
- 如果不采用强制写回策略，则我们需要用REDO

- 如果我们 FORCE 页面，在 FORCE 和 COMMIT 之间发生崩溃时，我们需要能够执行UNDO操作。

![截屏2024-07-17 08.05.20](http://198.46.215.27:49153/i/66970ac9943c4.png)

#### 非强制写回/Steal策略的恢复

在系统崩溃后，我们必须执行以下操作：

- **REDO已提交的“胜利”事务**
- **UNDO未提交的“失败”事务**

**赢家事务**指的是在日志中同时包含了事务开始（SOT）和提交（COMMIT）记录的事务。

- 这些事务需要通过REDO操作从头到尾重新执行。

**失败事务**指的是在日志中包含了事务开始（SOT），但没有提交（EOT），或者标记为ABORT的事务。这些事务需要通过UNDO操作，

- 按照相反的顺序，从末尾到开头进行撤销。

此外，我们还需要执行UNDO操作来撤销已中止（ABORT）的事务。



#### 恢复3阶段

- 分析： 扫描日志，找到胜利和失败事务
- 重做： 从头扫尾扫描日志，找到胜利事务
- 撤销：  从头扫尾扫描日志，找到失败事务

具体顺序可以有多种

- 先撤销在重做
- 先重做再撤销

下一节会详细讨论。

##### 案例分析

- 假设我们有三个事务，采用NO Force， Steal策略
- T1写A，commited
- T2写B，abort
- T3写C，系统crash

![截屏2024-07-17 09.09.38](http://198.46.215.27:49153/i/669719d7c8436.png)

----

恢复过程

![截屏2024-07-17 09.11.12](http://198.46.215.27:49153/i/66971a3598957.png)

- 分析： T1 是胜利事务，T2，T3是失败事务
- REDO：正向扫描，重放WA
- UNDO： 反向扫描，撤销WB，WC操作

恢复后，T1的效果还在，而T2，T3的就没了。

### 恢复和隔离性

- 在一个正确隔离的数据库中，如果使用页面级别的锁定，同时运行的事务不会读写同一页面
  - 因此，我