# 数据库存储

**磁盘导向架构**

有两个问题。

- DBMS如何表示用磁盘上的文件来表示数据库？
- DBMS如何管理他的内存，以及从磁盘上往返移动数据的？

分为3个部分讲解

- 文件存储
- 页的布局
- 元祖的布局

----



### 从内存到磁盘

#### 借助操作系统

> 如何存？OS的提供的mmap吗？

DBMS确实能够使用内存映射mmap来存储一个文件的内容到程序中指定的位置。OS也有责任将文件的页移到内存或者相反方向移动（通过虚拟内存），因此DBMS不需要担心内存和磁盘之间移动的问题。

<img src="/Users/mac/Library/Application%2520Support/typora-user-images/%25E6%2588%25AA%25E5%25B1%258F2024-07-18%252007.36.11.png" alt="截屏2024-07-18 07.36.11" style="zoom:50%;" />

> 那如果说有多个线程通过mmap一个文件来隐藏页面停顿呢？

只读访问时效果很好。当有多个写入者时，这会变得复杂……

**总结**

使用MMAP I/O有几个问题

- **事务安全**。 OS在任何时间都可能刷新脏页 
- **I/O 停顿**。DBMS不知道哪些页在内存中，OS会用页错误停顿一个线程
- **错误处理**。 在使用MMAP时，很难提前验证页面的有效性。任何对无效页面的访问都会引发SIGBUS信号，这是一种总线错误，DBMS需要处理这种错误以防止系统崩溃或数据损坏。
- **性能问题**。操作系统数据结构争用。 TLB失效，当多线程频繁访问不同的内存页面时，TLB可能会频繁失效，导致系统性能下降。

-----

但是也有应对这些问题解决方法

- **madvise**: 告知操作系统你预计如何读取某些页面
- **mlock**：告知操作系统内存范围不能被换出
- **msync**：告知操作系统将内存范围刷新到磁盘

历史中也有数据库采用这个方法。 比如SQLite， MongoDB(现在已经不用了）

----

DBMS（大部分）总是想自己控制所有的东西，并且确实也能做的比OS好 。

- 正确的顺序刷新脏页
- 专门的预取页
- 缓冲区替换策略
- 线程、进程的调度

**操作系统并不是你的朋友的！**（论文： Are You Sure You Want to Use MMAP in Your Database Mangement System?）

### 

### 文件存储

DBMS 通常以专有格式将数据库存储为一个或多个磁盘文件。

- OS对这些文件一无所知

**存储管理器**负责维护数据库文件

- 一些存储管理器自行调度读写操作，以提高页面的空间和时间局部性

它将文件组织为页面集合。

- 跟踪读取、写入页面的数据
- 跟踪可用空间

#### 页面(page)

一个页面是固定大小的数据块。

- 它可以包含元组、元数据、索引、日志记录等。
- 大多数系统不会混合页面类型（比如存记录的和存日志的混在一起）。
- 有些系统要求页面是自包含的（就是需要解释这个页所有元数据信息都要包含其中）。

每个页面都有一个唯一标识符（页ID，或者块ID）。

- DBMS 使用一个间接层将页面ID映射到物理位置。

#### 数据库的页

在DBMS里面有3种“页面”

- 硬件页面（通常是4KB）
- OS页（通常4KB）
- 数据库页（512B ~ 16KB）
  - 4K: SQLlite， Oracle
  - 8K: SQL Server 、PostgreSQL
  - 16K： MySQL
  - 更大的页需要的系统调用就比较少

硬件页面是存储设备能够保证安全（原子性）写入的最大数据块。

---

#### 页存储架构

不同的DBMS使用不同的方法管理磁盘文件中的页

- 堆文件组织
- 树形文件组织
- 顺序/有序文件组织（ISAM）
- 哈希文件组织

在层次结构的这一点上，我们不需要了解页面内部的具体内容。

##### 堆文件组织

堆文件是一个无序的页面集合，元组以随机顺序存储在页面中。每页都是等大小的。

![截屏2024-07-18 03.27.17](http://198.46.215.27:49153/i/66981b1c15dd5.png)

- 读、写、缓存数据都是在页的粒度下进行

- 堆扫描时， 按照存储顺序读取堆文件。即使有谓词，也要读取所有的文件

  ![截屏2024-07-18 09.35.03](http://198.46.215.27:49153/i/6698715141d13.png)

  - 获取第3页的数据可以通过计算 `Page# * PageSize` 来实现，其中Page#意思是页码
  - 通过页ID或者块ID来定位， 如果仅有一个单一文件，那么很容易找到页。

###### 页目录

DBMS 维护专门的页面，用于跟踪数据库文件中数据页面的位置（页在哪个文件的哪个位置上）。

- 必须确保目录页面与数据页面保持同步。

目录还记录关于可用空间的元数据：

- 每个页面的空闲槽位数量。
- 空闲/空页面的列表。

<img src="http://198.46.215.27:49153/i/66987fccb325e.png" alt="截屏2024-07-18 10.36.47" style="zoom: 50%;" />





### 页的布局

#### 页面头部

每个页都包含一个关于这个页的元数据的头部信息

- 页大小
- checksum
- DBMS版本
- 事务可视性信息
- 压缩信息

比如Oracle可能还需要一些自包含数据，关于怎么解读这些数据的schema信息等，用于恢复

----

>  如何组织页面内部的数据? 

有两种方法：

- 面向元组的
- 日志结构的

我们仍然假设只存储元组。

---

#### 元祖存储

初步想法：在页面中跟踪每个元组，通过追加的方式添加

<img src="http://198.46.215.27:49153/i/669821a948037.png" alt="截屏2024-07-18 03.55.11" style="zoom:50%;" />

- 当进行删除操作怎么办？
- 如果是变长的元祖怎么办？

----

##### 分槽页**(Slotted Page)**

最通用的布局方式叫做，分槽页。 用slot array映射出所有元组的起始位置，这个方法适合固定或者不定长的元祖。

- 头部跟踪以下内容：
  - 使用的槽数量
  - 最后一个槽的起始位置偏移量。这个信息有助于快速定位新的插入位置

![截屏2024-07-18 03.58.18](http://198.46.215.27:49153/i/669822637d2ae.png)

如果我删除了元祖3，会发生什么。

- 你可以只是放在那
- 要么将元组4滑过去，对于索引，来说，你只是索引的是slot，而不是slot指向的东西，因此，slot从指向元组4改成指向元祖3，且前提是已经复制过去了。对于索引没有任何影响。

#### 元组ID

DBMS需要一种方法跟踪每个元组，每个元组都会有一个元组ID。

- 最通用的方法： **page_id + offset/slot**
- 还可以包含文件位置信息

应用程序不能依赖这些ID来表示任何特定含义。因为这个ID可能会被数据更改，这是逻辑和物理之间的抽象或者分离，我们知道元祖是什么即知道他们的逻辑信息，但是实际存储在哪里，如何存储，我们不应该知道。



### 元组的布局

一个元组本质上是一系列字节。

 解释这些字节为属性类型和值是 DBMS 的职责。



#### 头部

每个元组前都有一个包含元数据的头部。

- 可见性信息（并发控制），比如删除了没有等等
- 用于表示NULL值的位图 

我们不需要存储关于schema的元数据。

![截屏2024-07-18 11.35.28](http://198.46.215.27:49153/i/66988d878fda2.png)

------

#### 数据部分

属性通常按创建表时指定的顺序存储。 这样做是出于软件工程的考虑（即简单性）。 然而，以不同的方式布局可能更高效。

![截屏2024-07-18 11.36.58](http://198.46.215.27:49153/i/66988de2088e5.png)

#### 非规范化数据

DBMS 可以在物理上进行非规范化（例如，"预连接"）相关元组，并将它们存储在同一页面中。有些系统中你可以将来自多个表的数据存储在一个元组中。

- 可能会减少常见工作负载模式下的I/O量。
- 可能会使更新变得更加昂贵。

![截屏2024-07-18 11.38.06](http://198.46.215.27:49153/i/66988e260a429.png)

<img src="http://198.46.215.27:49153/i/669890b3ca59a.png" alt="截屏2024-07-18 11.49.00" style="zoom: 50%;" />

也有不少NoSQL这样做，但不叫他物理非规范化

<img src="http://198.46.215.27:49153/i/669890c9a3fa1.png" alt="截屏2024-07-18 11.49.22" style="zoom:50%;" />

### 



### 结构化日志存储

**页面导向架构**

有两个情况：

- 向页面插入一个元祖

  → 检查页面目录，找到一个有空闲槽的页面。 

  → 从磁盘取回页面（如果不在内存中）。 

  → 检查槽数组，找到页面中适合新数据的空闲空间并插入。

- 通过它的记录ID更新已经存在的

  → 检查页面目录，找到页面的位置。 

  → 从磁盘取回页面（如果不在内存中）。 

  → 使用槽数组找到页面中的偏移量。 

  → 覆盖现有数据（如果新数据适合）。

> 分槽页设计有咩有一些潜在问题？

- 碎片化
- 无效的磁盘I/O。
- 随机磁盘I/O （比如，更新20个元组到20个不同的页面时，可能会导致大量的随机磁盘I/O操作）

> 如果数据库管理系统（DBMS）无法在页面中覆盖数据，只能创建新页面，会有什么问题？比如云存储（S3），HDFS

只能追加文件。

这就引出了另外一种方法 ——日志结构存储

--------

DBMS 存储的日志记录包括对元组的修改（PUT， DELETE)

- 每个日志记录必须包含元组的ID
- PUT操作必须包含元组的内容
- DELETE操作必须将元组标记为删除状态

当页面满了之后，数据库管理系统（DBMS）会将其写入磁盘，并开始使用下一个页面来存储记录。

- 所有的磁盘写入操作都是顺序的。
- 磁盘上的页面是不可变的。

要读取具有特定ID的元组，DBMS会查找与该ID对应的最新日志记录。

- 从最新到最旧扫描日志记录。
- 维护一个索引，将元组ID映射到最新的日志记录。
- 如果日志记录在内存中，则直接读取。
- 如果日志记录在磁盘页面上，则取回它。

![截屏2024-07-18 13.53.02](http://198.46.215.27:49153/i/6698adc912361.png)

#### 结构化日志压缩

日志会永久增长，因此DBMS需要定期压缩页来减少空间的浪费

![截屏2024-07-18 13.58.21](http://198.46.215.27:49153/i/6698af05dbfa4.png)

在页面被压缩后，数据库管理系统（DBMS）不需要维护页面内记录的时间顺序。

- 每个元组ID在页面中最多出现一次。

 相反，DBMS可以根据ID顺序对页面进行排序，以提高将来查找的效率。

- 这被称为Sorted String Tables（SSTables）。 
- ![截屏2024-07-18 14.03.38](http://198.46.215.27:49153/i/6698b04890a17.png)



用RocksDB而言有两种方式，

- Universal Compaction
- Level Compaction

​	![截屏2024-07-18 14.07.17](http://198.46.215.27:49153/i/6698b122186f4.png)

**日志结构化存储管理器如今更为常见**。这在一定程度上归因于RocksDB的普及。<img src="/Users/mac/Library/Application%2520Support/typora-user-images/%25E6%2588%25AA%25E5%25B1%258F2024-07-18%252014.14.45.png" alt="截屏2024-07-18 14.14.45" style="zoom:33%;" />

这种方法的一些缺点包括：

- **写放大（Write-Amplification）**写了一个记录，然后就不碰它了，导致每次压缩都得带上它，但是又消除不了。
- **压缩代价高昂（Compaction is Expensive）**

## 数据表示

> [!IMPORTANT]
>
> TODO: 各种数据类型的的表示方法这里并没有涉及

表结构类似如图

```css
  A  B  C  D
1
2
3
```

>  磁盘和内存是线性的，表是2维的，如何在磁盘上存储呢？

- 行优先——一次存储一行
- 列优先——一次存储一列

**行优先例子**

![截屏2024-07-18 03.15.34](http://198.46.215.27:49153/i/6698185d94096.png)

**列优先例子**

![截屏2024-07-18 03.16.42](http://198.46.215.27:49153/i/669818a15bbf9.png)

我们后面以行优先存储为主。

>  而且需要高效的支持插入，删除并且某些记录被读取的频率比其他记录高，该怎么办？

回答这个问题，需要了解如何访问数据的。



## 系统目录catalogs

元组本质上是一系列字节序列。数据库管理系统（DBMS）的任务是将这些字节解释为属性类型和值。

DBMS的目录包含关于系统使用的表的模式信息，这些信息帮助系统确定元组的布局。

------

数据库管理系统（DBMS）在其内部目录中存储关于数据库的元数据信息。

- 包括表、列、索引、视图等信息
- 用户、权限信息
- 内部统计信息

几乎每个DBMS都将数据库的目录信息存储在其内部（比如，在表上）。

- 通过元组封装对象抽象。
- 为“引导”目录表编写专门的代码。

-----

你可以查询DBMS的内部INFORMATION_SCHEMA目录，获取有关数据库的信息。

- INFORMATION_SCHEMA是ANSI标准的一组只读视图，提供有关数据库中所有表、视图、列和过程的信息。
- DBMS还具有非标准的快捷方式来检索这些信息。

### 获取表的schema

![截屏2024-07-18 14.55.11](http://198.46.215.27:49153/i/6698bc58bc495.png)